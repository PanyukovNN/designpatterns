## Вступление

Впервые были описаны в книге Design Patterns Elements of Reusable Object-Oriented Software более 20 лет назад 4 авторами, которых также называют бандой четырех или Gang of Four (GoF).

Паттерны это best practices по работе с ООП архитектурой, они помогают нам создавать читабельные, легко поддерживаемые и эффективные приложения. 
При этом они широко известны в сообществе, благодаря чему, новым разработчикам не составляет труда рабораться в коде, если они знакомы с паттернами.

С появлением Spring, применение большинства паттернов видоизменилось и это необходимо учитывать.

Зачем нужен этот доклад, если мы можем посмотреть все паттерны в интернете ?
1. В интернете все примеры очень искусственные и простые, это нам не помогает в работе
2. Реализация паттернов с использованием спринга отичается от классической
3. У большинства паттернов несколько сценариев применения, тогда как везде, как правило, приводят по одному примеру
4. Знание паттернов придаёт уверенности в работе

Для использования паттернов нам нужны определённые триггеры в коде, увидев которые мы поймём какой паттерн следует применить.

## Список GoF паттернов:

Порождающие:
1. Factory method
2. Abstract factory
3. Builder
4. Prototype
5. Singleton

Структурные:
1. Adapter
2. Bridge
3. Composite
4. Decorator
5. Facade
6. Flyweight
7. Proxy

Поведенческие:
1. Chain of responsibility
2. Command
3. Interpreter
4. Iterator
5. Mediator
6. Memento
7. Observer
8. State
9. Strategy
10. Template method
11. Visitor

Дополнительно:
1. Simple factory
2. Context
3. Template

Некоторые паттерны мы рассматривать не станем, а именно:
1. Singleton 
2. Prototype
3. Iterator

## Доклад №1

Рассмотрим все порождающие паттерны, плюс стратегию:
1. Factory
2. Simple Factory
3. Abstract Factory
4. Strategy
5. Builder


### Factory method 

В ООП любая фабрика это специальный объект, который может создавать другие объекты.

Фабричный метод, это метод, в который мы передаем некий параметр (удобнее всего передавать значение Enum) и в зависимости от его значения возвращаем соответствующий объект.
Спринг в своей работе активно использует фабричные методы.

Триггер - ключевое слово new. 

Варианты применения:
- используем фабричный метод, когда нам надо возвращать разные объекты в зависимости от значения Enum'а
- пользуемся встроенной фабрикой спринга, конфигурируем бины, когда нам нужно вернуть синглтоны из объекта внешних библиотек


### Simple Factory

Триггер - ключевое слово new. 

Может пригодится в случае создания например потоков (если найдете хороший пример будет отлично)

Применяем в случае когда нужно создавать каждый раз новый объект с предварительной конфигурацией

	
### Абстрактная фабрика. 

Суть паттерна в том, что в зависимости от параметра, мы возвращаем не конкретный объект, а фабрику, которая потом передается далее и может создавать объекты присущие тольео данному типу фабрики. 

Это довольно сложный паттерн и очень редко встречается на практике. 

Каких-либо вменяемых примеров мне найти не удалось.
Если найдете хорошие примеры, то буду благодарен.

Не используем, редко встречается на практике 


### Strategy

Суть стратегии - выбор разного алгоритма в зависимости от переданного параметра. Для выбора алгоритма в спринговой реализации используется паттерн фабричный метод.

Отличный пример это компаратор. Мы создаем стратегию стравнения объектов и передаем её сортировщику.

С приходом в java 8 стало возможно создавать стратегии из одной строчки.

Довольно понятный и эффективный паттерн, позволят вынести логику в разные классы и легко расширять приложение. 

Триггер для стратегии - условные операторы switch, if-else-if 


### Builder

Не изменился с приходом спринга.
Зачастую именно он сильно улучшает читаемость кода.

Имеет две классические реализации:
	- создается в отдельном классе
	- создается внутри класса (best practice)

Активно пользуемся этим паттерном.
Когда нужна валидация полей - пишем руками.

Триггеры:
	- сущность имеет большое количество полей 
	- метод имеет большое количество параметров
	- заполнение полей сущности раскидано по нескольким методам/классам
	- необходимо валидировать поля объекта при его создании


### Резюме по докладу №1 

Мы рассмотрели все порождающие паттерны проектирования. 
Разобрались в чем их отличия, а также как они реализуются с использованием Spring. 
Уже сейчас можем применять их на практике.



## Доклад №2

### Прокси
Предоставляет возможность обеспечения контроля доступа к определенному объекту.

Отличительные особенности прокси:
1. Вызываемый объект создается непосредственно внутри прокси
2. Не меняется контракт методов, не должно меняется их поведение
3. Разработчик не ожидает изменений в поведении при использовании прокси объекта

В спринг приложении следует применять с использованием аспектов.

Триггер:
В данном случае применяется общий триггер для аспектов, а именно cross-cutting функциональность, или по русски сквозная функциональность, примеры:
- логгирование
- отлов ошибок
- кеширование
- проверка прав доступа
- транзакции
- профайлинг
- и некоторые другие

Используем для сквозного функционала, в основном для реализации конкретных бизнес требований, не злоупотребляем, чтобы минимизировать неожиданное поведение.


## Декоратор
Позволяет динамически добавлять функциональность объекту. В основе лежит композиция, что является альтернативой наследованию, то есть мы можем добавлять объекту логику, оборачивая объект в декораторы, не используя наследование.

Можем встретить в jdk:
- Наследники InputStream, OutputStream
- Collections.unmodifiable...
- Collections.synchronized...

Отличительные особенности:
1. Вызываемый объект передается в конструктор декоратора
2. Не меняется контракт методов

Реализация в спринг:
1. Декорируемый объект помечается аннотацией @Primary
2. Создаем декораторы, которые в свою очередь будут автовайрить исходный сервис
3. Далее автовайрим нужный нам декоратор с помощью аннотации @Qualifier

С использованием спринга теряется возможность создавать вложенные декораторы.

Триггер:
- нам надо расширить или изменить поведение методов класса, когда нет других возможностей это сделать
- когда приходится создавать методы, которые вызывают методы этого же класса, при этом контракт не изменяется 

На небольших проектах, как правило, применяется редко.


## Адаптер
Преобразует интерфейс в интерфейс класса, необходимый клиенту. Используется для совместной работы классов, интерфейсы которых несовместимы.

Также часто встречается в базовых библиотеках java:
- Arrays.asList()
- InputStreamReader(inputStream) - возвращает reader

Отличительные особенности:
1. Рекоммендуется реализовывать сразу два интерфейса (если нет возможности, то хотя бы один интерфейс, чтобы при его изменении мы видели, что наш адаптер ломается)
2. Изменяет контракт методов (могут быть исключения).

Каких-либо отличий в реализации с помощью спринга нет.

Триггер:
Практически то же самое, что и у декоратора
- когда начинаем создавать метод, которые дергают методы этого же класса, изменяя контракта
- когда в коде встречаем конвертирование одного объекта в другой
- когда используем библиотечный класс, его нельзя изменить, но хотим сделать более удобный контракт

С помощью адаптера и декоратора мы можем практически как нам удобно модернизировать под себя код библиотек, по сути для этого они и нужны

На небольших проектах, как правило, применяется редко.


## Фасад
Предоставляет единый интерфейс для набора интерфейсов. Фасад представляет сообой более высокоуровневый интерфейс, который упрощает использовает подсистемы.

Каких-либо ярких отличительных черт не имеет, основное свойство - инкапсуляция вызова нескольких сервисов в одном месте.

Каких-либо отличий в реализации с помощью спринга нет.

Триггер
- сложная, неразрывная логика, с вызовом методов разных сервисов (либо нескольких методов одного сервиса)

Полагаю все достаточно хорошо чувствуют когда его стоит применять, поскольку сразу видно, что участок кода излишне сложен и его проще инкапсулировать в отдельный метод и с читабельным названием.


## Резюме по докладу №2
Сегодня мы рассмотрели наиболее часто встречаемые структурные паттерны, когда их стоит или не стоит применять. 
Разобрались в чём их отличия, как они реализуются с использованием Spring. 

## Общее резюме
Паттерны проектирования учат нас смотреть на решаемую проблему масштабнее, что позволяет нам писать читаемые и легко поддерживаемые программы. 
